# 指令实现情况检查报告

## 一、已实现的指令

### 1. ALU 指令（R-type）
✅ **全部已实现**
- ADD (6'b100000)
- ADDU (6'b100001)
- SUB (6'b100010)
- SUBU (6'b100011)
- SLL (6'b000000, shamt)
- SRL (6'b000010, shamt)
- SRA (6'b000011, shamt)
- SLLV (6'b000100)
- SRLV (6'b000110)
- SRAV (6'b000111)
- AND (6'b100100)
- OR (6'b100101)
- XOR (6'b100110)
- NOR (6'b100111)
- SLT (6'b101010)
- SLTU (6'b101011)

**实现位置**：`code/Ctrl.v` 第 129-144 行

### 2. 加载立即数到高位
✅ **已实现**
- LUI (6'b001111)

**实现位置**：`code/Ctrl.v` 第 98 行

### 3. 带有立即数的 ALU 指令
✅ **全部已实现**
- ADDI (6'b001000)
- ADDIU (6'b001001)
- ANDI (6'b001100)
- ORI (6'b001101)
- XORI (6'b001110)
- SLTI (6'b001010)
- SLTIU (6'b001011)

**实现位置**：`code/Ctrl.v` 第 118-124 行

### 4. 乘除法器指令
✅ **全部已实现**
- MULT (6'b011000)
- MULTU (6'b011001)
- DIV (6'b011010)
- DIVU (6'b011011)
- MFHI (6'b010000)
- MTHI (6'b010001)
- MFLO (6'b010010)
- MTLO (6'b010011)

**实现位置**：
- 控制信号：`code/Ctrl.v` 第 145-148, 152-155 行
- 乘除法单元：`code/MIPS.v` 第 101-110 行（使用 MDU.sv）

### 5. 分支指令
✅ **全部已实现**
- BEQ (6'b000100)
- BNE (6'b000101)
- BLEZ (6'b000110)
- BGTZ (6'b000111)
- BGEZ (6'b000001, Rt=00001)
- BLTZ (6'b000001, Rt=00000)

**实现位置**：
- 控制信号：`code/Ctrl.v` 第 103-114 行
- 比较逻辑：`code/Comp.v`
- 分支判断：`code/NPC.v`

### 6. 无条件跳转指令
✅ **全部已实现**
- JR (6'b001000, R-type)
- JALR (6'b001001, R-type)
- J (6'b000010)
- JAL (6'b000011)

**实现位置**：
- 控制信号：`code/Ctrl.v` 第 115-116, 150-151 行
- 跳转逻辑：`code/NPC.v`

### 7. 访存指令
✅ **全部已实现**
- LB (6'b100000) - 有符号字节加载
- LBU (6'b100100) - 无符号字节加载
- LH (6'b100001) - 有符号半字加载
- LHU (6'b100101) - 无符号半字加载
- LW (6'b100011) - 字加载
- SB (6'b101000) - 字节存储
- SH (6'b101001) - 半字存储
- SW (6'b101011) - 字存储

**实现位置**：
- 控制信号：`code/Ctrl.v` 第 94-102 行
- 数据存储器：`code/DM.v`
- 数据扩展：`code/DMExt.v`
- 字节使能控制：`code/BECtrl.v`

## 二、未实现或部分实现的指令

### ❌ SYSCALL 指令
**状态**：**未实现**

**问题描述**：
1. `code/Ctrl.v` 中 R-type 指令的 default 分支将 syscall 当作 NOP 处理（第 156 行）
2. 没有检测 syscall 指令（Op=000000, Funct=001100）
3. 没有实现 syscall 功能：
   - **syscall 10**：终止仿真（$finish）
   - **syscall 1**：输出整数（$a0 寄存器的值）

**需要的实现**：
1. 在 `Ctrl.v` 中添加 syscall 检测
2. 在 `MIPS.v` 中添加 syscall 处理逻辑：
   - 检测 syscall 指令（在 WB 阶段或 MEM 阶段）
   - 读取 $v0 寄存器（$2）的值
   - 如果 $v0 == 10：调用 `$finish` 终止仿真
   - 如果 $v0 == 1：读取 $a0 寄存器（$4）的值并使用 `$display` 输出

**建议实现位置**：
- 在 `MIPS.v` 的 WB 阶段添加 syscall 检测和处理
- 需要访问寄存器文件读取 $v0 和 $a0 的值

## 三、总结

| 指令类别 | 总数 | 已实现 | 未实现 |
|---------|------|--------|--------|
| ALU 指令 | 16 | 16 | 0 |
| 立即数 ALU 指令 | 7 | 7 | 0 |
| 乘除法指令 | 8 | 8 | 0 |
| 分支指令 | 6 | 6 | 0 |
| 跳转指令 | 4 | 4 | 0 |
| 访存指令 | 8 | 8 | 0 |
| **SYSCALL** | **1** | **0** | **1** |
| **总计** | **50** | **49** | **1** |

## 四、建议

为了完整实现所有要求的功能，需要：

1. **添加 syscall 指令检测**：
   - 在 `Ctrl.v` 的 R-type case 中添加 SYSCALL 的处理
   - 生成 `IsSyscallD` 信号并沿流水线传递

2. **实现 syscall 处理逻辑**：
   - 在 `MIPS.v` 的 WB 阶段检测 syscall 指令
   - 读取 $v0 寄存器判断功能号
   - 根据功能号执行相应操作：
     - 功能号 10：`$finish`
     - 功能号 1：`$display("%d", $a0)`

3. **测试验证**：
   - 编写包含 syscall 指令的测试程序
   - 验证 syscall 10 能正确终止仿真
   - 验证 syscall 1 能正确输出整数

